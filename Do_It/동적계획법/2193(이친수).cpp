// 규칙 찾아 피보나치 수열로도 해결 가능하지만, DP의 원리에 입각해 풀어보기

#include <iostream>

using namespace std;

int N;
long long answer[91][2];

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);
	cout.tie(NULL);

	cin >> N;

	// 맨 뒤자리가 1로 끝나면, 그 다음은 무조건 0이 와야 한다.
	// 맨 뒤자리가 0으로 끝나면, 그 다음은 0과 1 모두 올 수 있다.

	//	1 : 1 (1)								-> 맨 뒤가 1이므로, 그 다음은 0밖에 못 옴 (10)
	//	2 : 1 (10)								-> 맨 뒤가 0이므로, 그 다음은 0, 1 둘 다 가능 (100 101)
	//	3 : 2 (100 101)
	//	4 : 3 (1000 1001 1010)
	//	5 : 5 (10000 10001 10010 10100 10101)

	// answer[i][0] : 길이 i에서 끝이 0으로 끝나는 이친수의 개수
	// answer[i][1] : 길이 i에서 끝이 1로 끝나는 이친수의 개수

	answer[1][0] = 0;	// 이친수는 0으로 시작하지 않으므로, 1자리 면서 0으로 끝나는 이친수는 없음
	answer[1][1] = 1;	// 1은 이친수

	for (int i = 2; i <= N; i++) {
		answer[i][0] = answer[i - 1][0] + answer[i - 1][1];	// i - 1이 1로 끝나면, 그 다음은 무조건 0이고, i - 1이 0으로 끝나면 그 다음 값으로 0이 올 수 있음
		answer[i][1] = answer[i - 1][0];	// i - 1이 0으로 끝나면 그 다음은 1이 올 수 있음
	}

	cout << answer[N][0] + answer[N][1] << '\n';

	return 0;
}
